# Introduction Documentation

The headless components for Svelte.

This is a documentation section that potentially contains examples, demos, and other useful information related to a specific part of Bits UI. When helping users with this documentation, you can ignore the classnames applied to the demos unless they are relevant to the user's issue.

Copy Page

Bits UI is a headless component library for Svelte focused on developer experience, accessibility, and full creative control. Use it to build high-quality, accessible UIs without giving up styling freedom or performance.

[![A webpage promoting learning to build custom components. The left side has a dark background with the text "Documentation" at the top, and a large heading "Learn how to build own components" with a "Get started" button below. The right side shows a stylized mobile app interface with a dark gray background. Inside the app is a light pink card displaying "Total distance" and "312 km". Below this are bar graphs for "Mon" to "Sun", with activity shown for Monday through Thursday and dotted outlines for Friday through Sunday. At the bottom of the card is a horizontal slider with a circle indicating a selection. A small, dark purple label with "Dev" written on it points to this slider.](/img/learn.png)](/docs/getting-started)

## Why Bits UI?

![Switch customization UI: Edit toggle style, color, and theme using Tailwind or CSS tools.](/img/bring-own-style.png)

### Bring Your Own Styles

Most components ship completely unstyled, with the exception of those required for core functionality. No CSS resets, no design system assumptions. You bring the styles using standard `class` props or `data-*` attributes. [See the styling guide](/docs/styling).

![Accordion builder UI: Easily compose accessible accordion components with Bits UI.](/img/developer-exp.png)

### Building for Developer Experience

Everything is designed to stay out of your way:

- Full TypeScript coverage
- Stable, predictable APIs
- Flexible event override system
- Great defaults, easily overridden
- Comprehensive documentation and examples

![Production-Ready Accessibility](/img/accessibility.png)

### Production-Ready Accessibility

Accessibility isn't just an afterthought - it's baked in:

- WAI-ARIA compliance
- Keyboard navigation by default
- Focus management handled for you
- Screen reader support built-in

![Composable by Design](/img/composable2.png)

### Composable by Design

Components are primitives, not black boxes. They compose cleanly and play well together:

- [Render Delegation](/docs/child-snippet) for total flexibility
- Chainable events and callbacks
- Override-friendly defaults
- Minimal dependencies

## Community

Bits UI was built and is maintained by [Hunter Johnston](https://x.com/huntabyte) with design support from [Pavel Stianko](https://x.com/pavel_stianko) and his team at [Bitworks Studio](https://bitworks.cz) and tooling support from [Adrian Gonz](https://github.com/AdrianGonz97). Contributions, issues, and feedback are always welcome.

Found an issue? [Open one](https://github.com/huntabyte/bits-ui/issues/new). Have a feature request? [Let's discuss](https://github.com/huntabyte/bits-ui/discussions/new?category=feature-requests-ideas)

## Acknowledgments

Built on the shoulders of giants:

- [Melt UI](https://melt-ui.com) - inspired the internal architecture
- [Radix UI](https://radix-ui.com) - API design inspiration
- [React Spectrum](https://react-spectrum.adobe.com) - inspiration for the date/time components and excellence in accessibility

[Next Getting Started](/docs/getting-started)



# Child Snippet Documentation

Learn how to use the \`child\` snippet to render your own elements.

This is a documentation section that potentially contains examples, demos, and other useful information related to a specific part of Bits UI. When helping users with this documentation, you can ignore the classnames applied to the demos unless they are relevant to the user's issue.

Copy Page

The `child` snippet is a powerful feature that gives you complete control over the rendered elements in Bits UI components, allowing for customization while maintaining accessibility and functionality.

## When to Use It

You should use the `child` snippet when you need:

- Svelte-specific features like transitions, animations, actions, or scoped styles
- Integration with custom components in your application
- Precise control over the DOM structure
- Advanced composition of components

## Basic Usage

Many Bits UI components have default HTML elements that wrap their content. For example, `Accordion.Trigger` renders a `<button>` element by default:

```svelte
<button {...props}>
  {@render children()}
</button>
```

When you need to customize this element, the `child` snippet lets you take control:

```svelte
<script lang="ts">
  import MyCustomButton from "$lib/components";
  import { Accordion } from "bits-ui";
</script>
<Accordion.Trigger>
  {#snippet child({ props })}
    <MyCustomButton {...props}>Toggle Item</MyCustomButton>
  {/snippet}
</Accordion.Trigger>
<!-- or -->
<Accordion.Trigger>
  {#snippet child({ props })}
    <button {...props} class="scoped-button">Toggle Item</button>
  {/snippet}
</Accordion.Trigger>
<style>
  .scoped-button {
    background-color: #3182ce;
    color: #fff;
  }
</style>
```

In this example:

- The `props` parameter contains all necessary attributes and event handlers
- The `{...props}` spread applies these to your custom element/component
- You can add scoped styles, transitions, actions, etc. directly to the element

## How It Works

When you use the `child` snippet:

1. The component passes all internal props and your custom props passed to the component via the `props` snippet parameter
2. You decide which element receives these props
3. The component's internal logic continues to work correctly

### Behind the Scenes

Components that support the `child` snippet typically implement logic similar to:

```svelte
<script lang="ts">
  // Bits UI component internal logic
  let { child, children, ...restProps } = $props();
  const trigger = makeTrigger();
  // Merge internal props with user props
  const mergedProps = $derived(mergeProps(restProps, trigger.props));
</script>
{#if child}
  {@render child({ props: mergedProps })}
{:else}
  <button {...mergedProps}>
    {@render children?.()}
  </button>
{/if}
```

## Working with Props

### Custom IDs & Attributes

To use custom IDs, event handlers, or other attributes, pass them to the component first:

```svelte
<Accordion.Trigger
  id="my-custom-id"
  data-testid="accordion-trigger"
  onclick={() => console.log("clicked")}
>
  {#snippet child({ props })}
    <button {...props}>Open accordion item</button>
  {/snippet}
</Accordion.Trigger>
```

The `props` object will now include:

- Your custom ID (`id="my-custom-id"`)
- Your data attribute (`data-testid="accordion-trigger"`)
- Your click event handler, properly merged with internal handlers
- All required ARIA attributes and internal event handlers

## Combining with Svelte Features

You can apply Svelte-specific features to your custom elements, such as transitions, actions, and scoped styles:

```svelte
<Accordion.Trigger>
  {#snippet child({ props })}
    <div {...props} use:myCustomAction class="my-custom-trigger">
      <!-- ... -->
    </div>
  {/snippet}
</Accordion.Trigger>
<style>
  .my-custom-trigger {
    background-color: #3182ce;
    color: #fff;
  }
</style>
```

## Floating Components

Floating content components (tooltips, popovers, dropdowns, etc.) require special handling due to their positioning requirements.

### Required Structure

For floating components, you must use a two-level structure:

1. An **outer wrapper element** with `{...wrapperProps}`
2. An **inner content element** with `{...props}`

```svelte
<Popover.Content>
  {#snippet child({ wrapperProps, props, open })}
    {#if open}
      <div {...wrapperProps}>
        <div {...props}>
          <!-- ... -->
        </div>
      </div>
    {/if}
  {/snippet}
</Popover.Content>
```

### Important Rules for Floating Content

- The wrapper element with `{...wrapperProps}` must remain **unstyled**
- Positioning is handled by the wrapper element; styling goes on the inner content element
- The `open` parameter lets you conditionally render the content, triggering Svelte transitions
- Always maintain this two-level structure to ensure proper positioning and behavior

### Components Requiring Wrapper Elements

The following components require a wrapper element:

- `Combobox.Content`
- `DatePicker.Content`
- `DateRangePicker.Content`
- `DropdownMenu.Content`
- `LinkPreview.Content`
- `Menubar.Content`
- `Popover.Content`
- `Select.Content`
- `Tooltip.Content`

## Examples

### Basic Custom Element

```svelte
<Collapsible.Trigger>
  {#snippet child({ props })}
    <button {...props}>
      <Icon name="star" />
      <span>Favorite</span>
    </button>
  {/snippet}
</Collapsible.Trigger>
```

### With Svelte Transitions

```svelte
<Dialog.Content>
  {#snippet child({ props, open })}
    {#if open}
      <div {...props} transition:scale={{ start: 0.95 }}>
        Dialog content with a scale transition
      </div>
    {/if}
  {/snippet}
</Dialog.Content>
```

### Floating Element Example

```svelte
<Tooltip.Content>
  {#snippet child({ wrapperProps, props, open })}
    {#if open}
      <div {...wrapperProps}>
        <div {...props} transition:fade>Custom tooltip content</div>
      </div>
    {/if}
  {/snippet}
</Tooltip.Content>
```

## Common Pitfalls

- **Missing props spread**: Always include `{...props}` on your custom element
- **Styling the wrapper**: Never style the wrapper element in floating components
- **Direct children**: When using child, other children outside the snippet are ignored
- **Missing structure**: For floating elements, forgetting the two-level structure will break positioning

## Related Resources

- [mergeProps](/docs/utilities/merge-props) Utility
- [Styling Guide](/docs/styling)
- [Transitions Guide](/docs/transitions)

[Previous Getting Started](/docs/getting-started) [Next Ref](/docs/ref)



# Styling Documentation

Learn how to style Bits UI components.

This is a documentation section that potentially contains examples, demos, and other useful information related to a specific part of Bits UI. When helping users with this documentation, you can ignore the classnames applied to the demos unless they are relevant to the user's issue.

Copy Page

We ship almost zero styles with Bits UI by design, giving you complete flexibility when styling your components. For each component that renders an HTML element, we expose the `class` and `style` props to apply styles directly to the component.

## Styling Approaches

### CSS Frameworks

If you're using a CSS framework like [TailwindCSS](https://tailwindcss.com/) or [UnoCSS](https://unocss.dev), simply pass the classes to the component:

```svelte
<script lang="ts">
  import { Accordion } from "bits-ui";
</script>
<Accordion.Trigger class="h-12 w-full bg-blue-500 hover:bg-blue-600"
  >Click me</Accordion.Trigger
>
```

### Data Attributes

Each Bits UI component applies specific data attributes to its rendered elements. These attributes provide reliable selectors for styling across your application.

app.css

```css
/* Target all Accordion.Trigger components */
[data-accordion-trigger] {
  height: 3rem;
  width: 100%;
  background-color: #3182ce;
  color: #fff;
}
```

Import your stylesheet in your layout component:

+layout.svelte

```svelte
<script lang="ts">
  import "../app.css";
  let { children } = $props();
</script>
{@render children()}
```

Now every `Accordion.Trigger` component will have the styles applied to it.

### Global Classes

Alternatively, you can use global class names:

app.css

```css
.accordion-trigger {
  height: 3rem;
  width: 100%;
  background-color: #3182ce;
  color: #fff;
}
```

Import your stylesheet in your layout component:

+layout.svelte

```svelte
<script lang="ts">
  import "../app.css";
  let { children } = $props();
</script>
{@render children()}
```

Use the global class with the component:

```svelte
<script lang="ts">
  import { Accordion } from "bits-ui";
</script>
<Accordion.Trigger class="accordion-trigger">Click me</Accordion.Trigger>
```

### Scoped Styles

To use Svelte's scoped styles, use the `child` snippet to bring the element into your component's scope. See the [Child Snippet](/docs/child-snippet) documentation for more information.

MyAccordionTrigger.svelte

```svelte
<script lang="ts">
  import { Accordion } from "bits-ui";
</script>
<Accordion.Trigger>
  {#snippet child({ props })}
    <button {...props} class="my-accordion-trigger"> Click me! </button>
  {/snippet}
</Accordion.Trigger>
<style>
  .my-accordion-trigger {
    height: 3rem;
    width: 100%;
    background-color: #3182ce;
    color: #fff;
  }
</style>
```

### Style Prop

All Bits UI components that render an element accept a style prop as either a string or an object of CSS properties. These are merged with internal styles using the [`mergeProps`](/docs/utilities/merge-props) function.

```svelte
<Accordion.Trigger style="background-color: #3182ce; color: white; padding: 1rem;">
	Click me
</Accordion.Trigger>
<!-- Or using an object -->
<Accordion.Trigger
  style={{ backgroundColor: "#3182ce", color: "white", padding: "1rem" }}
>
  Click me
</Accordion.Trigger>
```

## Styling Component States

Bits UI components may expose state information through data attributes and CSS variables, allowing you to create dynamic styles based on component state.

### State Data Attributes

Components apply state-specific data attributes that you can target in your CSS:

```css
/* Style the Accordion.Trigger when open */
[data-accordion-trigger][data-state="open"] {
  background-color: #f0f0f0;
  font-weight: bold;
}
/* Style the Accordion.Trigger when closed */
[data-accordion-trigger][data-state="closed"] {
  background-color: #ffffff;
}
/* Style disabled components */
[data-accordion-trigger][data-disabled] {
  opacity: 0.5;
  cursor: not-allowed;
}
```

See each component's API reference for its specific data attributes.

### CSS Variables

Bits UI components may expose CSS variables that allow you to access internal component values. For example, to ensure the `Select.Content` is the same width as the anchor (by default is the `Select.Trigger` unless using a `customAnchor`), you can use the `--bits-select-anchor-width` CSS variable:

```css
[data-select-content] {
  width: var(--bits-select-anchor-width);
  min-width: var(--bits-select-anchor-width);
  max-width: var(--bits-select-anchor-width);
}
```

See each component's API reference for specific CSS variables it provides.

### Example: Styling an Accordion

Here's an example styling an accordion with different states:

```svelte
<script lang="ts">
  import { Accordion } from "bits-ui";
</script>
<Accordion.Root>
  <Accordion.Item value="item-1">
    <Accordion.Trigger>Section 1</Accordion.Trigger>
    <Accordion.Content>Content for section 1</Accordion.Content>
  </Accordion.Item>
  <Accordion.Item value="item-2">
    <Accordion.Trigger disabled>Section 2 (Disabled)</Accordion.Trigger>
    <Accordion.Content>Content for section 2</Accordion.Content>
  </Accordion.Item>
</Accordion.Root>
<style>
  /* Base styles */
  :global([data-accordion-item]) {
    border: 1px solid #e2e8f0;
    border-radius: 0.25rem;
    margin-bottom: 0.5rem;
  }
  /* Trigger styles based on state */
  :global([data-accordion-trigger]) {
    width: 100%;
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  :global([data-accordion-trigger][data-state="open"]) {
    background-color: #f7fafc;
    border-bottom: 1px solid #e2e8f0;
  }
  :global([data-accordion-trigger][data-disabled]) {
    opacity: 0.5;
    cursor: not-allowed;
  }
  /* Content styles */
  :global([data-accordion-content]) {
    padding: 1rem;
  }
</style>
```

## Advanced Styling Techniques

### Combining Data Attributes with CSS Variables

You can combine data attributes with CSS variables to create dynamic styles based on component state. Here's how to animate the accordion content using the `--bits-accordion-content-height` variable and the `data-state` attribute:

```css
/* Basic transition animation */
[data-accordion-content] {
  overflow: hidden;
  transition: height 300ms ease-out;
  height: 0;
}
[data-accordion-content][data-state="open"] {
  height: var(--bits-accordion-content-height);
}
[data-accordion-content][data-state="closed"] {
  height: 0;
}
```

### Custom Keyframe Animations

For more control, use keyframe animations with the CSS variables:

```css
/* Define keyframes for opening animation */
@keyframes accordionOpen {
  0% {
    height: 0;
    opacity: 0;
  }
  80% {
    height: var(--bits-accordion-content-height);
    opacity: 0.8;
  }
  100% {
    height: var(--bits-accordion-content-height);
    opacity: 1;
  }
}
/* Define keyframes for closing animation */
@keyframes accordionClose {
  0% {
    height: var(--bits-accordion-content-height);
    opacity: 1;
  }
  20% {
    height: var(--bits-accordion-content-height);
    opacity: 0.8;
  }
  100% {
    height: 0;
    opacity: 0;
  }
}
/* Apply animations based on state */
[data-accordion-content][data-state="open"] {
  animation: accordionOpen 400ms cubic-bezier(0.16, 1, 0.3, 1) forwards;
}
[data-accordion-content][data-state="closed"] {
  animation: accordionClose 300ms cubic-bezier(0.7, 0, 0.84, 0) forwards;
}
```

### Example: Animated Accordion

Here's an example of an accordion with a custom transition:

```svelte
<script lang="ts">
  import { Accordion } from "bits-ui";
</script>
<Accordion.Root type="single">
  <Accordion.Item value="item-1">
    <Accordion.Trigger>Section 1</Accordion.Trigger>
    <Accordion.Content>Content for section 1</Accordion.Content>
  </Accordion.Item>
  <Accordion.Item value="item-2">
    <Accordion.Trigger>Section 2</Accordion.Trigger>
    <Accordion.Content>Content for section 2</Accordion.Content>
  </Accordion.Item>
</Accordion.Root>
<style>
  /* Base styles */
  :global([data-accordion-item]) {
    border: 1px solid #e2e8f0;
    border-radius: 0.25rem;
    margin-bottom: 0.5rem;
  }
  /* Trigger styles based on state */
  :global([data-accordion-trigger]) {
    width: 100%;
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  :global([data-accordion-trigger][data-state="open"]) {
    background-color: #f7fafc;
    border-bottom: 1px solid #e2e8f0;
  }
  /* Content styles */
  :global([data-accordion-content]) {
    overflow: hidden;
    transition: height 300ms ease-out;
  }
  /* Define keyframes for opening animation */
  @keyframes -global-accordionOpen {
    0% {
      height: 0;
      opacity: 0;
    }
    80% {
      height: var(--bits-accordion-content-height);
      opacity: 0.8;
    }
    100% {
      height: var(--bits-accordion-content-height);
      opacity: 1;
    }
  }
  /* Define keyframes for closing animation */
  @keyframes -global-accordionClose {
    0% {
      height: var(--bits-accordion-content-height);
      opacity: 1;
    }
    20% {
      height: var(--bits-accordion-content-height);
      opacity: 0.8;
    }
    100% {
      height: 0;
      opacity: 0;
    }
  }
  /* Apply animations based on state */
  :global([data-accordion-content][data-state="open"]) {
    animation: accordionOpen 400ms cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }
  :global([data-accordion-content][data-state="closed"]) {
    animation: accordionClose 300ms cubic-bezier(0.7, 0, 0.84, 0) forwards;
  }
</style>
```

[Previous Transitions](/docs/transitions) [Next Dates](/docs/dates)




# Dates and Times Documentation

How to work with the various date and time components in Bits UI.

This is a documentation section that potentially contains examples, demos, and other useful information related to a specific part of Bits UI. When helping users with this documentation, you can ignore the classnames applied to the demos unless they are relevant to the user's issue.

Copy Page

The date and time components in Bits UI leverage the [@internationalized/date](https://react-spectrum.adobe.com/internationalized/date/index.html) package, providing a unified API for working with dates and times across different locales and time zones. This package is inspired by the [Temporal](https://tc39.es/proposal-temporal/) proposal and is designed to seamlessly integrate with the Temporal API once it becomes available.

## Installation

You can install the package using your favorite package manager:

```bash
npm install @internationalized/date
```

It's highly recommended to familiarize yourself with the package's documentation before diving into the components. We'll cover the basics of how we use the package in Bits UI in the sections below, but their documentation provides much more detail on the various formats and how to work with them.

## DateValue Types

Bits UI uses `DateValue` objects from `@internationalized/date` to represent dates and times consistently. These immutable objects provide specific information about the type of date they represent:

We use the `DateValue` objects provided by `@internationalized/date` to represent dates and times in a consistent way. These objects are immutable and provide information about the type of date they represent. The `DateValue` is a union of the following three types:

| Type               | Description                 | Example                                          |
| ------------------ | --------------------------- | ------------------------------------------------ |
| `CalendarDate`     | Date without time component | `2024-07-10`                                     |
| `CalendarDateTime` | Date with time              | `2024-07-10T12:30:00`                            |
| `ZonedDateTime`    | Date with time and timezone | `2024-07-10T21:00:00:00-04:00[America/New_York]` |

Using these strongly-typed objects allows components to adapt appropriately to the date type you provide.

### CalendarDate

Represents a date without a time component.

```ts
// Creating a CalendarDate
import {
  CalendarDate,
  parseDate,
  today,
  getLocalTimeZone,
} from "@internationalized/date";
// From year, month, day parameters
const date = new CalendarDate(2024, 7, 10);
// From ISO 8601 string
const parsedDate = parseDate("2024-07-10");
// Current date in specific timezone
const losAngelesToday = today("America/Los_Angeles");
// Current date in user's timezone
const localToday = today(getLocalTimeZone());
```

See the [CalendarDate API Documentation](https://react-spectrum.adobe.com/internationalized/date/CalendarDate.html) for additional methods.

### CalendarDateTime

Represents a date with a time component, but without timezone information.

```ts
// Creating a CalendarDateTime
import { CalendarDateTime, parseDateTime } from "@internationalized/date";
// From date and time components
const dateTime = new CalendarDateTime(2024, 7, 10, 12, 30, 0);
// From ISO 8601 string
const parsedDateTime = parseDateTime("2024-07-10T12:30:00");
```

See the [CalendarDateTime API documentation](https://react-spectrum.adobe.com/internationalized/date/CalendarDateTime.html) for additional methods.

### ZonedDateTime

Represents a specific date and time in a specific timezone - crucial for events that occur at an exact moment regardless of the user's location (like conferences or live broadcasts).

```ts
// Creating a ZonedDateTime
import {
  ZonedDateTime,
  parseZonedDateTime,
  parseAbsolute,
  parseAbsoluteToLocal,
} from "@internationalized/date";
const date = new ZonedDateTime(
  2022,
  2,
  3, // Date (year, month, day)
  "America/Los_Angeles", // Timezone
  -28800000, // UTC offset in milliseconds
  9,
  15,
  0 // Time (hour, minute, second)
);
// From ISO 8601 strings using different parsing functions
const date1 = parseZonedDateTime("2024-07-12T00:45[America/New_York]");
const date2 = parseAbsolute("2024-07-12T07:45:00Z", "America/New_York");
const date3 = parseAbsoluteToLocal("2024-07-12T07:45:00Z");
```

See the [ZonedDateTime API documentation](https://react-spectrum.adobe.com/internationalized/date/ZonedDateTime.html) for more information.

## Working with Date Ranges

For components that require date ranges, Bits UI provides a `DateRange` type:

```ts
type DateRange = {
  start: DateValue;
  end: DateValue;
};
```

This type is used in components such as:

- [Date Range Field](/docs/components/date-range-field)
- [Date Range Picker](/docs/components/date-range-picker)
- [Range Calendar](/docs/components/range-calendar)

## Using the Placeholder

Each date/time component in Bits UI has a *bindable* `placeholder` prop that serves multiple important functions:

1. **Starting Point**: Acts as the initial date when no value is selected
2. **Type Definition**: Determines what type of date/time to display if value is absent
3. **Calendar Navigation**: Controls the visible date range in calendar views

### Example: Using Placeholder with Calendar

```svelte
<script lang="ts">
  import { Calendar } from "bits-ui";
  import {
    today,
    getLocalTimeZone,
    type DateValue,
  } from "@internationalized/date";
  // Initialize placeholder with today's date
  let placeholder: DateValue = $state(today(getLocalTimeZone()));
  let selectedMonth: number = $state(placeholder.month);
</script>
<!-- Month selector to control calendar view -->
<select
  onchange={() => {
    placeholder = placeholder.set({ month: selectedMonth });
  }}
  bind:value={selectedMonth}
>
  <option value={1}>January</option>
  <option value={2}>February</option>
  <!-- Additional months... -->
</select>
<Calendar.Root bind:placeholder>
  <!-- Calendar components... -->
</Calendar.Root>
```

## Updating DateValue Objects

Since `DateValue` objects are immutable, you must create new instances when updating them:

```ts
// INCORRECT - will not work
let placeholder = new CalendarDate(2024, 7, 10);
placeholder.month = 8; // Error! DateValue objects are immutable
// CORRECT - using methods that return new instances
let placeholder = new CalendarDate(2024, 7, 10);
// Method 1: Using set()
placeholder = placeholder.set({ month: 8 });
// Method 2: Using add()
placeholder = placeholder.add({ months: 1 });
// Method 3: Using subtract()
placeholder = placeholder.subtract({ days: 5 });
// Method 4: Using cycle() - cycles through valid values
placeholder = placeholder.cycle("month", "forward", [1, 3, 5, 7, 9, 11]);
```

## Formatting and Parsing

### Formatting Dates for Display

For consistent, locale-aware date formatting, use the `DateFormatter` class:

```ts
import { DateFormatter } from "@internationalized/date";
// Create a formatter for the current locale
const formatter = new DateFormatter("en-US", {
  dateStyle: "full",
  timeStyle: "short",
});
// Format a DateValue
const formattedDate = formatter.format(myDateValue.toDate("America/New_York"));
// Example output: "Wednesday, July 10, 2024 at 12:30 PM"
```

The `DateFormatter` wraps the native [Intl.DateTimeFormat API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat) while fixing browser inconsistencies and polyfilling newer features.

### Parsing Date Strings

When working with date strings from APIs or databases, use the appropriate parsing function for your needs:

```ts
import {
  parseDate, // For CalendarDate
  parseDateTime, // For CalendarDateTime
  parseZonedDateTime, // For ZonedDateTime with timezone name
  parseAbsolute, // For ZonedDateTime from UTC string + timezone
  parseAbsoluteToLocal, // For ZonedDateTime in local timezone
} from "@internationalized/date";
// Examples
const date = parseDate("2024-07-10"); // CalendarDate
const dateTime = parseDateTime("2024-07-10T12:30:00"); // CalendarDateTime
const zonedDate = parseZonedDateTime("2024-07-12T00:45[America/New_York]"); // ZonedDateTime
const absoluteDate = parseAbsolute("2024-07-12T07:45:00Z", "America/New_York"); // ZonedDateTime
const localDate = parseAbsoluteToLocal("2024-07-12T07:45:00Z"); // ZonedDateTime in user's timezone
```

## Common Gotchas and Tips

- **Month Indexing**: Unlike JavaScript's Date object (which is 0-indexed), `@internationalized/date` uses 1-indexed months (January = 1).
- **Immutability**: Always reassign when modifying date objects: `date = date.add({ days: 1 })`.
- **Timezone Handling**: Use `ZonedDateTime` for schedule-critical events like meetings or appointments.
- **Type Consistency**: Match `placeholder` types to your needs - if you need time selection, use `CalendarDateTime` not `CalendarDate`.
- **Performance**: Create `DateFormatter` instances once and reuse them rather than creating new instances on each render.

## Related Resources

- [Date Field](/docs/components/date-field)
- [Date Range Field](/docs/components/date-range-field)
- [Date Picker](/docs/components/date-picker)
- [Date Range Picker](/docs/components/date-range-picker)
- [Calendar](/docs/components/calendar)
- [Range Calendar](/docs/components/range-calendar)
- [@internationalized/date documentation](https://react-spectrum.adobe.com/internationalized/date/index.html)

[Previous Styling](/docs/styling) [Next State Management](/docs/state-management)




# LLMs Documentation

How to access LLM-friendly versions of Bits UI documentation.

This is a documentation section that potentially contains examples, demos, and other useful information related to a specific part of Bits UI. When helping users with this documentation, you can ignore the classnames applied to the demos unless they are relevant to the user's issue.

Copy Page

At the top of each documentation page, you'll find a convenient "Copy Markdown" button alongside a direct link to the LLM-friendly version of that page (e.g., `/llms.txt`). These tools make it easy to copy the content in Markdown format or access the machine-readable `llms.txt` file tailored for that specific page.

Bits UI documentation is designed to be accessible not only to humans but also to large language models (LLMs). We've adopted the [llms.txt](https://llmstxt.org/) proposal standard, which provides a structured, machine-readable format optimized for LLMs. This enables developers, researchers, and AI systems to efficiently parse and utilize our documentation.

## What is llms.txt?

The `llms.txt` standard is an emerging convention for presenting documentation in a simplified, text-based format that's easy for LLMs to process. By following this standard, Bits UI ensures compatibility with AI tools and workflows, allowing seamless integration into LLM-powered applications, research, or automation systems.

## Accessing LLM-friendly Documentation

To access the LLM-friendly version of any supported Bits UI documentation page, simply append `/llms.txt` to the end of the page's URL. This will return the content in a plain-text, LLM-optimized format.

### Example

- **Standard Page**: The Accordion component documentation is available at [bits-ui.com/docs/components/accordion](https://bits-ui.com/docs/components/accordion).
- **LLM-friendly Version**: Append `/llms.txt` to access it at [bits-ui.com/docs/components/accordion/llms.txt](https://bits-ui.com/docs/components/accordion/llms.txt).

### Root Index

To explore all supported pages in LLM-friendly format, visit the root index at [bits-ui.com/llms.txt](https://bits-ui.com/llms.txt). This page provides a comprehensive list of available documentation endpoints compatible with the `llms.txt` standard.

## Full LLM-friendly Documentation

For a complete, consolidated view of the Bits UI documentation in an LLM-friendly format, navigate to [bits-ui.com/docs/llms.txt](https://bits-ui.com/docs/llms.txt). This single endpoint aggregates all documentation content into a machine-readable structure, ideal for bulk processing or ingestion into AI systems.

## Notes

- Not all pages may support the `/llms.txt` suffix (those deemed irrelevant to LLMs, such as the Figma page). Check the root [bits-ui.com/llms.txt](https://bits-ui.com/llms.txt) page for an up-to-date list of compatible URLs.
- The "Copy Markdown" button at the top of each page provides the same content you'd find in the `/llms.txt` of that page.

By embracing the `llms.txt` standard, Bits UI empowers both human developers and AI systems to make the most of our documentation. Whether you're building with Bits UI or training an LLM, these tools are designed to enhance your experience.

[Previous Migration Guide](/docs/migration-guide) [Next Accordion](/docs/components/accordion)

